<!DOCTYPE html>
<html lang="en">
<head>

  <!--
    The charset is crucial and has to be delivered as soon as possible!
    If you delay this after the title and your inline styles, this will
    be flagged by a few performance analytics tools.
  -->
  <meta charset="UTF-8" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />

  <title>Title of the project</title>

  <!-- Resource Hints: https://www.w3.org/TR/resource-hints/#resource-hints

    rel="dns-prefetch" makes sure that third-party contents from a
    specific URL are loaded faster. How? We do the DNS handshake now
    and not when said file is requested, so we have that part of the
    whole connection process out of the way already.

    When this is helpful? Are you using a CDN for assets? Do you use
    webfonts being served from a third-party domain? Here you go!
    Oh, Analytics are another option.

    This attribute has great support: http://caniuse.com/#feat=link-rel-dns-prefetch
  -->
  <link rel="dns-prefetch" href="http://whatever-domain.abc" />

  <!--
    On top of the above you could do the complete DNS, TCP, TLS
    handshake in the background with the following rel-attribute.

    Make sure to add the crossorigin boolean!

    Support's pretty awesome now: http://caniuse.com/#feat=link-rel-preconnect
  -->
  <link rel="preconnect" href="http://whatever-domain.abc" crossorigin />

  <!--
    If there is a single file you wish to prefetch for your visitors,
    you can do so as well. You could go the route of telling the
    browser that a certain resource is needed on subsequent visits,
    so it will be loaded at some point and be placed in the visitor's
    cache.
    Could be a file on your server or whereever.
  -->
  <link rel="prefetch" href="file.xyz" />

  <!--
    All of the above being said: Don't overdo this. The more you
    add the more you're back to the standard way browsers request
    your files over the network.
    Making all files high priority won't make the UX any better may be
    you'll make it even worse as browsers are already quite savvy
    with prioritizing.
  -->

  <!--
    Now for something special: rel="prerender"...
    1. You shouldn't do this to your users, as this will download
      a whole page and all files related to it into the users
      cache (more realistically it's an invisible tab in the back).
    2. You can do this for pages you know your visitors will visit
      next on your own website. For example in a shop, where you
      know that people who look at their cart might check out of
      the shop next. So on the cart.html page you set a <link>
      element in the head with rel="prerender" and a href of
      checkout.html for example. The checkout will render
      instantly - no loading time.

    The worst thing would be to load a whole different domain
    with this technique. You would add huge amounts of data to
    your visitors' cache without knowing, if they're ever going to
    use it because sometimes people don't do what you want them
    to do on your website. Amazing! Right? ;-)
  -->
  <link rel="prerender" href="probably-next-page.extension" />

  <!-- Inline Styles from the above-the-fold Stylesheet -->
  <style>/* Above the fold CSS goes here */</style>

  <!--
    The most recent link-rel-thingy we got and it is already supported in
    Chrome & Firefox & we got a polyfill for it: preload. preload is like
    ServerPush because you can send files over to the user while the HTML
    is downloading.

    Nice technique*: in order to prevent a stylesheet from blocking the
    rendering path but have it at your user's machine asap, we can do the
    following.

    *: See the <noscript> section at the end of the <head> section of this
    page for the fallback to this technique.
  -->
  <link rel="preload" href="link/to/your/stylesheet.css" as="style" onload="this.rel='stylesheet'" />

  <!-- You don't have JS or preload supported - no big deal -->
  <noscript><link href="css/projectname.main.min.css" media="all" rel="stylesheet" /></noscript>

  <!-- Descriptions are for Search Eng... for Google. -->
  <meta content="Description of the project" name="description" />
  <!-- And just for good measure and because it's fun to have the discussion over and over again -->
  <meta content="keywords, lol, rofl, omg, keywords" name="keywords" />

  <!-- Win8 Tile Icons -->
  <meta content="Projectname" name="application-name" />
  <meta content="#fff" name="msapplication-TileColor" />
  <meta content="images/projectname-msapp-70-70.png" name="msapplication-square70x70logo" />
  <meta content="images/projectname-msapp-150-150.png" name="msapplication-square150x150logo" />
  <meta content="images/projectname-msapp-310-150.png" name="msapplication-wide310x150logo" />
  <meta content="images/projectname-msapp-310-310.png" name="msapplication-square310x310logo" />

  <!-- Apple Touch Icons -->
  <link href="images/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed" />
  <link href="images/apple-touch-icon-57x57-precomposed.png" sizes="57x57" rel="apple-touch-icon-precomposed" />
  <link href="images/apple-touch-icon-72x72-precomposed.png" sizes="72x72" rel="apple-touch-icon-precomposed" />
  <link href="images/apple-touch-icon-114x114-precomposed.png" sizes="114x114" rel="apple-touch-icon-precomposed" />
  <link href="images/apple-touch-icon-144x144-precomposed.png" sizes="144x144" rel="apple-touch-icon-precomposed" />

  <!-- Favicon for all IE browsers below IE10 -->
  <!--[if IE]><link href="favicon.ico" rel="icon" /><![endif]-->
  <!-- Favicon for all browsers being capable of using a PNG file -->
  <link href="images/favicon.png" rel="icon" />
  <!--
    All the rest can fallback to the default behaviour of taking
    the favicon.ico file in the root-directory
  -->

  <!-- Social Media Stuff -->
  <meta content="Title of the project" property="og:title" />
  <meta content="website" property="og:type" />
  <meta content="http://www.projectname.com" property="og:url" />
  <meta content="Description of the project." property="og:description" />
  <meta content="images/projectname-200x200.jpg" property="og:image" />
  <link href="images/projectname-200x200.jpg" rel="image_src" />

  <!--
    Entirely optional but better than loading respond.js if you
    need support for IE8:
  -->
  <!--[if lt IE 9]><link href="ie8-specific-stylesheet.css" type="text/css" media="all" rel="stylesheet" /><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <!--
    Did you know that media="print" will prevent the stylesheetdownload from
    blocking rendering? Me neither but it doesn't. Great.
  -->
  <link href="css/projectname.print.min.css" media="print" rel="stylesheet" />

</head>
<body>

  <!-- Development -->
  <script src="concatenated/projectname.js"></script>

  <!-- Production
  <script src="js/projectname.min.js"></script>
  -->

  <!--
    loadCSS for true asynchronous stylesheet loading. Just pass it your CSS files.
  -->
  <script>(function(w){"use strict";var loadCSS=function(href,before,media){var doc=w.document;var ss=doc.createElement("link");var ref;if(before){ref=before}else{var refs=(doc.body||doc.getElementsByTagName("head")[0]).childNodes;ref=refs[refs.length-1]}var sheets=doc.styleSheets;ss.rel="stylesheet";ss.href=href;ss.media="only x";function ready(cb){if(doc.body){return cb()}setTimeout(function(){ready(cb)})}ready(function(){ref.parentNode.insertBefore(ss,before?ref:ref.nextSibling)});var onloadcssdefined=function(cb){var resolvedHref=ss.href;var i=sheets.length;while(i--){if(sheets[i].href===resolvedHref){return cb()}}setTimeout(function(){onloadcssdefined(cb)})};function loadCB(){if(ss.addEventListener){ss.removeEventListener("load",loadCB)}ss.media=media||"all"}if(ss.addEventListener){ss.addEventListener("load",loadCB)}ss.onloadcssdefined=onloadcssdefined;onloadcssdefined(loadCB);return ss};if(typeof exports!=="undefined"){exports.loadCSS=loadCSS}else{w.loadCSS=loadCSS}})(typeof global!=="undefined"?global:this);loadCSS('css/projectname.min.css');</script>

  <!--
    When using <link rel="preload" /> you'll want to polyfill non-supporting browsers.
    This polyfill relies on loadCSS.
  -->
  <script>(function(w){if(!w.loadCSS){return}var rp=loadCSS.relpreload={};rp.support=function(){try{return w.document.createElement("link").relList.supports("preload")}catch(e){return false}};rp.poly=function(){var links=w.document.getElementsByTagName("link");for(var i=0;i<links.length;i++){var link=links[i];if(link.rel==="preload"&&link.getAttribute("as")==="style"){w.loadCSS(link.href,link);link.rel=null}}};if(!rp.support()){rp.poly();var run=w.setInterval(rp.poly,300);if(w.addEventListener){w.addEventListener("load",function(){w.clearInterval(run)})}if(w.attachEvent){w.attachEvent("onload",function(){w.clearInterval(run)})}}})(this);</script>
</body>
</html>
